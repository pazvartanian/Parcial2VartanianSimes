<html>
<head>
<title>HashMap.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #bbb529;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
HashMap.h</font>
</center></td></tr></table>
<pre><span class="s0">//</span>
<span class="s0">// Created by Usuario on 19/10/2022.</span>
<span class="s0">//</span>

<span class="s2">#ifndef </span><span class="s1">PARCIAL2_SIMESVARTANIAN_HASHMAP_H</span>
<span class="s2">#define </span><span class="s1">PARCIAL2_SIMESVARTANIAN_HASHMAP_H</span>
<span class="s2">#include </span><span class="s3">&quot;HashEntry.h&quot;</span>
<span class="s2">#include</span><span class="s3">&lt;iostream&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;cstddef&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;string&gt;</span>
<span class="s2">#include </span><span class="s3">&quot;Lista.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;NodoLista.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;Colisiones.h&quot;</span>

<span class="s0">//Función HASH realiza alguna operación (la que querramos)</span>
<span class="s0">//al parámetro pasado por argumeto para codificarla o encriptarla.</span>
<span class="s0">//Devuelve un valor entero entre 0 y el tamaño de la tabla hash menos uno.</span>
<span class="s0">//Ese es el índice!</span>
<span class="s0">//Toda tabla hash tiene un tamaño preDefinido. Estructura ESTÁTICA.</span>
<span class="s0">//La Tabla no aplica ningún ordenamiento como lo hacen los árboles y</span>
<span class="s0">//demás estructuras.</span>



<span class="s4">template</span><span class="s1">&lt;</span><span class="s4">class </span><span class="s1">K</span><span class="s4">, class </span><span class="s1">T&gt; </span><span class="s4">class </span><span class="s1">HashMap {</span>

<span class="s4">private</span><span class="s1">:</span>
    <span class="s0">/** 
     * Cada HashENtry es una fila de la tabla. 
     */</span>
    <span class="s1">HashEntry&lt;K</span><span class="s4">, </span><span class="s1">T&gt; **tabla</span><span class="s4">;</span><span class="s0">//puntero a puntero. Convertiremos a un arreglo de punteros.</span>

    <span class="s4">unsigned int </span><span class="s1">tamanio</span><span class="s4">;</span><span class="s0">//Tamaño de tabla</span>

    <span class="s0">//Función Hash.</span>
    <span class="s0">/** 
     * static para poderla invocar por fuera de la 
     * clase sin crear un objeto de la clase. 
     * @param clave 
     * @return el índice 
     */</span>
    <span class="s4">static unsigned int </span><span class="s1">hashFunc(K clave)</span><span class="s4">;</span>

    <span class="s0">//puntero a función. Dirección de memoria de función.</span>
    <span class="s0">//Permite cambiar de una a otra función hash.</span>
    <span class="s4">unsigned int </span><span class="s1">(*hashFuncP)(K clave)</span><span class="s4">;</span>

    <span class="s1">Lista&lt;T&gt; listacolisiones4</span><span class="s4">;</span>


<span class="s4">public</span><span class="s1">:</span>
    <span class="s0">//tipo de dato explicit: elconstructor de tipo de dato explícito</span>
    <span class="s0">// permite generar una instancia de la clase pasando por</span>
    <span class="s0">//parámetro sin tener que definir un puntero.</span>
    <span class="s4">explicit </span><span class="s1">HashMap(</span><span class="s4">unsigned int </span><span class="s1">k)</span><span class="s4">;</span><span class="s0">//k: tamaño de tabla.</span>

    <span class="s0">//Constructor con puntero a función hash pasado por parámetro.</span>
    <span class="s1">HashMap(</span><span class="s4">unsigned int </span><span class="s1">k</span><span class="s4">, unsigned int </span><span class="s1">(*hashFuncP)(K clave))</span><span class="s4">;</span>

<span class="s0">//Devuelve el dato a partir de la clave. COmo un array. De manera</span>
<span class="s0">//inmediata aunque dependiente de la cant de colisiones y el factor</span>
<span class="s0">// de carga: ocupación de la tabla en relación la cantidad total</span>
<span class="s0">// de lugares en la tabla.</span>
<span class="s0">/** 
* Devuelve el dato a partir de la clave. COmo un array. De manera 
* inmediata aunque dependiente de la cant de colisiones y el 
 * factor de carga: ocupación de la tabla en relación la 
 * cantidad total de lugares en la tabla. 
 * @param clave 
 * @return 
 */</span>
    <span class="s1">T get(K clave)</span><span class="s4">;</span>

    <span class="s0">/** 
     * Inserta un valor en una posición obtenido el función hash 
     * @param clave 
     * @param valor 
     */</span>
    <span class="s4">void </span><span class="s1">put(K clave</span><span class="s4">, </span><span class="s1">T valor)</span><span class="s4">;</span>

    <span class="s4">void </span><span class="s1">remove(K clave)</span><span class="s4">;</span>

    <span class="s1">~HashMap()</span><span class="s4">;</span>

    <span class="s4">bool </span><span class="s1">esVacio()</span><span class="s4">;</span>

    <span class="s4">void </span><span class="s1">print()</span><span class="s4">;</span>

    <span class="s4">void </span><span class="s1">arregloconocurrencias (T arrn[])</span><span class="s4">;</span>

   <span class="s4">int </span><span class="s1">arregloconclaves (K arrc[]</span><span class="s4">, int </span><span class="s1">cantp)</span><span class="s4">;</span>

   <span class="s0">// int rellenoArreglos (int ArrN[], std::string C[]);</span>



<span class="s1">}</span><span class="s4">;</span>

<span class="s4">template </span><span class="s1">&lt;</span><span class="s4">class </span><span class="s1">K</span><span class="s4">, class </span><span class="s1">T&gt;</span>
<span class="s1">HashMap&lt;K</span><span class="s4">, </span><span class="s1">T&gt;::HashMap(</span><span class="s4">unsigned int </span><span class="s1">k) { </span><span class="s0">//Constructor que acepta por parámetro el tamaño de la tabla</span>
    <span class="s1">tamanio = k</span><span class="s4">;</span>
    <span class="s0">//Un arreglo de tamaño tamanio de punteros. Cada puntero es una fila de la tabla</span>
    <span class="s1">tabla = </span><span class="s4">new </span><span class="s1">HashEntry&lt;K</span><span class="s4">, </span><span class="s1">T&gt; *[tamanio]</span><span class="s4">;</span>

    <span class="s0">//Inicializamos las filas</span>
    <span class="s4">for </span><span class="s1">(</span><span class="s4">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; tamanio</span><span class="s4">; </span><span class="s1">i++) {</span>
        <span class="s1">tabla[i] = NULL</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s0">//Función de Hash por defecto</span>
    <span class="s1">hashFuncP = hashFunc</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">template</span><span class="s1">&lt;</span><span class="s4">class </span><span class="s1">K</span><span class="s4">, class </span><span class="s1">T&gt;</span>
<span class="s1">HashMap&lt;K</span><span class="s4">, </span><span class="s1">T&gt;::HashMap(</span><span class="s4">unsigned int </span><span class="s1">k</span><span class="s4">, unsigned int </span><span class="s1">(*fp)(K)) {</span>
    <span class="s1">tamanio = k</span><span class="s4">;</span>
    <span class="s1">tabla = </span><span class="s4">new </span><span class="s1">HashEntry&lt;K</span><span class="s4">, </span><span class="s1">T&gt; *[tamanio]</span><span class="s4">;</span>
    <span class="s4">for </span><span class="s1">(</span><span class="s4">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; tamanio</span><span class="s4">; </span><span class="s1">i++) {</span>
        <span class="s1">tabla[i] = NULL</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s1">hashFuncP = fp</span><span class="s4">; </span><span class="s0">//Función de Hash aceptada por parámetro</span>
<span class="s1">}</span>

<span class="s4">template</span><span class="s1">&lt;</span><span class="s4">class </span><span class="s1">K</span><span class="s4">, class </span><span class="s1">T&gt;</span>
<span class="s1">HashMap&lt;K</span><span class="s4">, </span><span class="s1">T&gt;::~HashMap() {</span>
    <span class="s4">for </span><span class="s1">(</span><span class="s4">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; tamanio</span><span class="s4">; </span><span class="s1">i++) {</span>
        <span class="s4">if </span><span class="s1">(tabla[i] != NULL) {</span>
            <span class="s4">delete </span><span class="s1">tabla[i]</span><span class="s4">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">template</span><span class="s1">&lt;</span><span class="s4">class </span><span class="s1">K</span><span class="s4">, class </span><span class="s1">T&gt;</span>
<span class="s1">T HashMap&lt;K</span><span class="s4">, </span><span class="s1">T&gt;::get(K clave) {</span>
    <span class="s4">unsigned int </span><span class="s1">pos = hashFuncP(clave) % tamanio</span><span class="s4">;</span><span class="s0">//operación módulo</span>

    <span class="s0">//Corroboramos si en esa posición</span>
    <span class="s4">if </span><span class="s1">(tabla[pos] == NULL) {</span>
        <span class="s4">throw </span><span class="s5">404</span><span class="s4">;</span>
    <span class="s1">}</span>
    <span class="s0">//obtenida la posición se busca dato</span>
    <span class="s4">return </span><span class="s1">tabla[pos]-&gt;getValor()</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">template</span><span class="s1">&lt;</span><span class="s4">class </span><span class="s1">K</span><span class="s4">, class </span><span class="s1">T&gt;</span>
<span class="s4">void </span><span class="s1">HashMap&lt;K</span><span class="s4">, </span><span class="s1">T&gt;::put(K clave</span><span class="s4">, </span><span class="s1">T valor) {</span>

    <span class="s4">unsigned int </span><span class="s1">pos = hashFuncP(clave) % tamanio</span><span class="s4">;</span>
    <span class="s4">int </span><span class="s1">keyrepetida = pos</span><span class="s4">;</span>
    <span class="s4">int </span><span class="s1">bandera = </span><span class="s5">0</span><span class="s4">;</span>


    <span class="s4">if </span><span class="s1">(tabla[pos] != NULL) {</span>

        <span class="s0">//MANEJO DE COLISIÓN NECESARIO!!!</span>
        <span class="s4">if </span><span class="s1">(tabla[pos]-&gt;getClave() == clave) {</span>

            <span class="s0">//si ya existe esa clave entonces que le agregue uno a su valor</span>
            <span class="s1">tabla[pos]-&gt;setValor(tabla[pos]-&gt;getValor() + </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

            <span class="s4">return;</span>
        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
            <span class="s1">pos = Colisiones(clave) % tamanio</span><span class="s4">;</span>

            <span class="s4">if </span><span class="s1">(tabla[pos] != NULL) {</span>

                <span class="s4">if </span><span class="s1">(tabla[pos]-&gt;getClave() == clave) {</span>
                    <span class="s1">tabla[pos]-&gt;setValor(tabla[pos]-&gt;getValor() + </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>
                    <span class="s4">return;</span>
                <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
                    <span class="s1">pos = Colisiones2(clave) % tamanio</span><span class="s4">;</span>

                    <span class="s4">if </span><span class="s1">(tabla[pos] != NULL) {</span>

                        <span class="s4">if </span><span class="s1">(tabla[pos]-&gt;getClave() == clave) {</span>
                            <span class="s1">tabla[pos]-&gt;setValor(tabla[pos]-&gt;getValor() + </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

                            <span class="s4">return;</span>
                        <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
                            <span class="s1">pos = Colisiones3(clave) % tamanio</span><span class="s4">;</span>


                            <span class="s4">if </span><span class="s1">(tabla[pos] != NULL) {</span>

                                <span class="s4">if </span><span class="s1">(tabla[pos]-&gt;getClave() == clave) {</span>

                                    <span class="s1">tabla[pos]-&gt;setValor(tabla[pos]-&gt;getValor() + </span><span class="s5">1</span><span class="s1">)</span><span class="s4">;</span>

                                    <span class="s4">return;</span>
                                <span class="s1">} </span><span class="s0">//aca deberia agregar el metodo de la lista agregar nodo courrencias a la lista y agregar una lista a la fila del hash q simule tener otra fila per en relidad sea un nodo</span>
                                <span class="s4">else </span><span class="s1">{</span>

                                    <span class="s1">listacolisiones4.ocurrencias(clave)</span><span class="s4">;</span>
                                    <span class="s1">bandera = </span><span class="s5">1</span><span class="s4">;</span>

                                <span class="s1">}</span>

                            <span class="s1">}</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>

                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(bandera == </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s1">tabla[pos] = </span><span class="s4">new </span><span class="s1">HashEntry&lt;K</span><span class="s4">, </span><span class="s1">T&gt;(clave</span><span class="s4">, </span><span class="s1">valor)</span><span class="s4">; </span><span class="s0">//Corresponde a una nueva fila en la tabla</span>

    <span class="s1">}</span>
<span class="s1">}</span>


<span class="s4">template</span><span class="s1">&lt;</span><span class="s4">class </span><span class="s1">K</span><span class="s4">, class </span><span class="s1">T&gt;</span>
<span class="s4">void </span><span class="s1">HashMap&lt;K</span><span class="s4">, </span><span class="s1">T&gt;::remove(K clave) {</span>
    <span class="s4">unsigned int </span><span class="s1">pos = hashFuncP(clave) % tamanio</span><span class="s4">;</span>
    <span class="s1">tabla[pos] = NULL</span><span class="s4">;</span>
<span class="s1">}</span>

<span class="s4">template</span><span class="s1">&lt;</span><span class="s4">class </span><span class="s1">K</span><span class="s4">, class </span><span class="s1">T&gt;</span>
<span class="s4">bool </span><span class="s1">HashMap&lt;K</span><span class="s4">, </span><span class="s1">T&gt;::esVacio() {</span>
    <span class="s4">for </span><span class="s1">(</span><span class="s4">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; tamanio</span><span class="s4">; </span><span class="s1">i++) {</span>
        <span class="s4">if </span><span class="s1">(tabla[i] != NULL) { </span><span class="s0">//Si al menos una de sus filas es != a nulo</span>
            <span class="s4">return false; </span><span class="s0">//No es vacía</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">return true;</span>
<span class="s1">}</span>

<span class="s4">template</span><span class="s1">&lt;</span><span class="s4">class </span><span class="s1">K</span><span class="s4">, class </span><span class="s1">T&gt;</span>
<span class="s4">unsigned int </span><span class="s1">HashMap&lt;K</span><span class="s4">, </span><span class="s1">T&gt;::hashFunc(K clave) { </span><span class="s0">//Función de Hash por defecto</span>
    <span class="s4">return </span><span class="s1">(</span><span class="s4">unsigned int</span><span class="s1">) clave</span><span class="s4">; </span><span class="s0">//Funciona sólo si K = int</span>
<span class="s1">}</span>

<span class="s4">template</span><span class="s1">&lt;</span><span class="s4">class </span><span class="s1">K</span><span class="s4">, class </span><span class="s1">T&gt;</span>
<span class="s4">void </span><span class="s1">HashMap&lt;K</span><span class="s4">, </span><span class="s1">T&gt;::print() {</span>
    <span class="s1">std::cout &lt;&lt; </span><span class="s3">&quot;i&quot; </span><span class="s1">&lt;&lt; </span><span class="s3">&quot;</span><span class="s4">\t</span><span class="s3">&quot; </span><span class="s1">&lt;&lt; </span><span class="s3">&quot;Clave&quot; </span><span class="s1">&lt;&lt; </span><span class="s3">&quot;</span><span class="s4">\t</span><span class="s3">&quot; </span><span class="s1">&lt;&lt; </span><span class="s3">&quot;Valor&quot; </span><span class="s1">&lt;&lt; std::endl</span><span class="s4">;</span>
    <span class="s1">std::cout &lt;&lt; </span><span class="s3">&quot;---------------------&quot; </span><span class="s1">&lt;&lt; std::endl</span><span class="s4">;</span>
    <span class="s4">for </span><span class="s1">(</span><span class="s4">int </span><span class="s1">pos = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">pos &lt; tamanio</span><span class="s4">; </span><span class="s1">pos++) {</span>
        <span class="s1">std::cout &lt;&lt; pos &lt;&lt; </span><span class="s3">&quot;</span><span class="s4">\t</span><span class="s3">&quot;</span><span class="s4">;</span>
        <span class="s4">if </span><span class="s1">(tabla[pos] != NULL) {</span>
            <span class="s1">std::cout &lt;&lt; tabla[pos]-&gt;getClave() &lt;&lt; </span><span class="s3">&quot;</span><span class="s4">\t</span><span class="s3">&quot;</span><span class="s4">;</span>
            <span class="s1">std::cout &lt;&lt; tabla[pos]-&gt;getValor()</span><span class="s4">;</span>
        <span class="s1">}</span>
        <span class="s1">std::cout &lt;&lt; std::endl</span><span class="s4">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">//metodo q m devuelva arreglo con ocurrencuas</span>
<span class="s4">template</span><span class="s1">&lt;</span><span class="s4">class </span><span class="s1">K</span><span class="s4">, class </span><span class="s1">T&gt;</span>
<span class="s4">void </span><span class="s1">HashMap&lt;K</span><span class="s4">, </span><span class="s1">T&gt;::arregloconocurrencias(T arrn[]) {</span>
    <span class="s4">for </span><span class="s1">(</span><span class="s4">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; tamanio</span><span class="s4">; </span><span class="s1">i++) {</span>

        <span class="s4">if </span><span class="s1">(tabla[i] != NULL) {</span>
            <span class="s1">arrn[i] = tabla[i]-&gt;getValor()</span><span class="s4">;</span>
        <span class="s1">}</span><span class="s4">else if </span><span class="s1">(!listacolisiones4.esVacia()){</span>
            <span class="s1">arrn[i] = listacolisiones4.getOcurr(</span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>

            <span class="s1">listacolisiones4.remover(</span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>

        <span class="s1">}</span>
        <span class="s4">else if </span><span class="s1">(tabla[i]==NULL)</span>
        <span class="s1">{</span>
            <span class="s1">arrn[i]= -</span><span class="s5">1</span><span class="s4">;</span>
        <span class="s1">}</span>

    <span class="s1">}</span>

<span class="s1">}</span>
<span class="s4">template</span><span class="s1">&lt;</span><span class="s4">class </span><span class="s1">K</span><span class="s4">, class </span><span class="s1">T&gt;</span>
<span class="s4">int </span><span class="s1">HashMap&lt;K</span><span class="s4">, </span><span class="s1">T&gt;::arregloconclaves(K *arrc</span><span class="s4">, int </span><span class="s1">cantrepetidas) {</span>

    <span class="s4">for </span><span class="s1">(</span><span class="s4">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s4">; </span><span class="s1">i &lt; tamanio</span><span class="s4">; </span><span class="s1">i++) {</span>

        <span class="s4">if </span><span class="s1">(tabla[i] != NULL) {</span>
            <span class="s1">arrc[i] =tabla[i]-&gt;getClave()</span><span class="s4">;</span>
        <span class="s1">}</span><span class="s4">else if </span><span class="s1">(!listacolisiones4.esVacia()) {</span>
            <span class="s1">arrc[i] = listacolisiones4.getDato(</span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>

            <span class="s1">listacolisiones4.remover(</span><span class="s5">0</span><span class="s1">)</span><span class="s4">;</span>
        <span class="s1">}</span>
        <span class="s4">else </span><span class="s1">{</span>
            <span class="s1">arrc[i]= </span><span class="s3">&quot; NULL&quot;</span><span class="s4">;</span>
            <span class="s1">cantrepetidas++</span><span class="s4">;</span>
        <span class="s1">}</span>

    <span class="s1">}</span>
    <span class="s4">return </span><span class="s1">cantrepetidas</span><span class="s4">;</span>

<span class="s1">}</span>


<span class="s0">/* template &lt;class K, class T&gt; int HashMap&lt;K,T&gt;::rellenoArreglos(int arregloOcu[], std:: string arregloPal[]) { 
    int contador= 0 ; 
 
    for (int i=0; i&lt;tamanio; i++){ 
        if (tabla[i] != NULL){ 
            arregloOcu[i] = tabla[i]-&gt;getValor(); 
            arregloPal[i] = tabla[i] -&gt;getClave(); 
        } else { 
            arregloOcu[i]= -1; 
            arregloPal[i]= &quot;NULL&quot; ; 
 
            contador++ ; 
        } 
    } 
    return contador ; 
} 
 */</span>

<span class="s2">#endif </span><span class="s0">//PARCIAL2_SIMESVARTANIAN_HASHMAP_H</span>

<span class="s0">//pq funciona el put solo con algunas palabfas</span></pre>
</body>
</html>